#!/usr/bin/env python

# kano-tracker-ctl
#
# Copyright (C) 2015 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
#

"""
kano-tracker-ctl is a controller for kano-tracker.

Usage:
  kano-tracker-ctl status
  kano-tracker-ctl update [-w]
  kano-tracker-ctl session (start|end) <name> <pid>
  kano-tracker-ctl -h|--help
  kano-tracker-ctl --version

 Options:
   -h, --help       Show this message.
   --version        Print the version.
   -w, --watch      Keep updating the tracking data periodically.
"""

import sys
import os
import docopt
import json
import datetime
import time

if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(1, dir_path)

from kano_profile.paths import tracker_dir, tracker_data_file
from kano_profile.tracker import open_locked, session_start, session_end, \
    get_session_file_path
from kano.logging import logger
from kano.utils import delete_file, ensure_dir
from kano.colours import decorate_string_only_terminal


def show_status():
    """ Show running application that are being tracked at the moment. """

    _process_tracker_data(_show_app_cb)


def update_status(watch=False):
    if not watch:
        return _do_update_status()

    MINUTES = 60
    started = time.time()
    while True:
        logger.info("Updating session tracking data")
        _do_update_status()

        elapsed = time.time() - started
        if elapsed <= 20 * MINUTES:
            time.sleep(2 * MINUTES)
        elif elapsed <= 60 * MINUTES:
            time.sleep(5 * MINUTES)
        else:
            time.sleep(15 * MINUTES)

def _do_update_status():
    done = _process_tracker_data(_update_app_cb)

    DAY_IN_SEC = 60*60*24

    # Make sure the tracker file exists
    if not os.path.exists(tracker_data_file):
        with open_locked(tracker_data_file, 'w') as f:
            json.dump({'usage': {}}, f)

    with open_locked(tracker_data_file, 'r') as rf:
        tracker_data = json.load(rf)

        if 'usage' not in tracker_data:
            tracker_data['usage'] = {}
        usage = tracker_data['usage']

        for path, app in done.iteritems():
            if not app:
                continue

            if app['name'] not in usage:
                usage[app['name']] = {}
            app_usage = usage[app['name']]

            if 'daily' not in app_usage:
                app_usage['daily'] = {}
            daily_data = app_usage['daily']

            day = app['started']
            elapsed = app['elapsed']
            while elapsed > DAY_IN_SEC:
                _add_daily_stats(daily_data, day, DAY_IN_SEC)
                day += DAY_IN_SEC
                elapsed -= DAY_IN_SEC

            if elapsed > 0:
                _add_daily_stats(daily_data, day, elapsed)

            delete_file(path)

        with open(tracker_data_file, 'w') as wf:
            json.dump(tracker_data, wf)


def _add_daily_stats(daily_data, day, elapsed):
    """ This adds the elapsed time to the stats of the respective day.

        It expects elapsed to be less than a day's worth of seconds.

        :param daily_data: The dictionary with daily data for this app.
        :type daily_data: dict

        :param day: A timestamp of the day for this statistic.
        :type day: number

        :param elapsed: The number of seconds passed. Must be less
                        than a full day.
        :type elapsed: number
    """

    strday = datetime.datetime.fromtimestamp(day).strftime('%Y-%m-%d')
    if strday not in daily_data:
        daily_data[strday] = {
            'starts': 0,
            'runtime': 0
        }

    daily_data[strday]['starts'] += 1
    daily_data[strday]['runtime'] += elapsed/60


def _show_app_cb(path, app):
    if not app:
        return

    heading = "{}[{}]".format(
        decorate_string_only_terminal(app['name'], 'extended(208)'),
        decorate_string_only_terminal(app['pid'], 'extended(244)')
    )

    status = ""
    if _check_pid(int(app['pid'])):
        status = decorate_string_only_terminal('RUNNING', 'extended(119)',
                                               bold=True)
    else:
        if 'finished' in app and app['finished']:
            status = decorate_string_only_terminal('FINISHED', 'extended(75)',
                                                   bold=True)
        else:
            status = decorate_string_only_terminal('CRASHED', 'extended(160)',
                                                   bold=True)

    print "{} {} {} seconds".format(heading, status, app['elapsed'])


def _update_app_cb(path, app):
    if not app:
        # The file could not be read and is probably corrupted: remove it.
        delete_file(path)
        return

    if 'finished' in app and app['finished'] == True:
        # Return the app to the parent function to be added to the
        # tracking store.
        return app

    if _check_pid(int(app['pid'])):
        app['elapsed'] = int(time.time() - app['started'])

        # WARNING: Don't use open_locked, the file has been locked already.
        with open(path, "w") as f:
            json.dump(app, f)

    else:
        # Application is not running, but not marked finished.
        # Return it as finished to be handled and removed.
        return app

    return


def _process_tracker_data(callback):
    """ Calls the function passed for each tracker file.

        They can be either running, crashed or finished, the user is
        expected to test that based on the pid.

        :param callback: The function to call on each tracker file. The
            callback should be as quick as possible as the file remains
            locked throughout the execution time.
        :type callback: function(path, app)

        :returns: Return values indexed by the path to its tracker file.
        :rtype: dict
    """

    ensure_dir(tracker_dir)

    rvs = {}
    for name in os.listdir(tracker_dir):
        path = os.path.join(tracker_dir, name)

        if not os.path.isfile(path):
            continue

        with open_locked(path, 'r') as f:
            try:
                app = json.load(f)
            except:
                # Cannot read the file
                app = None

            rvs[path] = callback(path, app)

    return rvs


def _check_pid(pid):
    """ Check For the existence of a unix pid. """

    try:
        os.kill(pid, 0)
    except OSError:
        return False
    else:
        return True


def main():
    args = docopt.docopt(__doc__, version='1.3')

    if args['status']:
        show_status()
    elif args['update']:
        update_status(args['--watch'])
    elif args['session'] and args['start']:
        session_start(args['<name>'], args['<pid>'])
    elif args['session'] and args['end']:
        session_end(get_session_file_path(args['<name>'], args['<pid>']))

    return 0


if __name__ == "__main__":
    sys.exit(main())
